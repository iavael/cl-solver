(defun calculate-expr (x &aux value)
  (cond
    ((numberp x) x)
    ((atom x)
      (if (setq value (get x 'value))
        (calculate-expr value)
        x))
    (t (apply-expr
         (first x)
         (mapcar
           (function calculate-expr)
           (cdr x))))))
(defun apply-expr (operation args &aux (op (get operation 'fn)))
  (if op
    (apply op args)
    (list
      op
      (calculate-expr (first args))
      (calculate-expr (second args)))))
(defmacro defaction (action args body)
  `(setf (get ',action 'fn) #'(lambda ,args ,body)))
(defmacro regroup-proto (oplist arglist1 arglist2 val-arg)
  `(if
    (numberp ,val-arg)
    (calculate-expr
      `(,,(first oplist)
         ,,(first arglist1)
         ,,(first arglist2)))
    (calculate-expr
      `(,,(second oplist)
         ,,(second arglist1)
         ,,(second arglist2)))))
(defmacro regroup (op1 op2 val-arg list-val1 list-val2)
  `(regroup-proto
     (,op1 ,op2)
     ((,op2 ,val-arg ,list-val1)
     (,op1 ,val-arg ,list-val2))
     (,list-val2
     ,list-val1)
     ,val-arg))
;(defmacro regroup-gen (op1 op2 op3 op4 val1-arg val2-arg val3-arg val4-arg)
;  `(regroup-proto
;     (,op1 ,op2)
;     (,val1-arg ,val2-arg)
;     (,val3-arg ,val4-arg)))
(defaction + (x y)
  (cond
    ((and (numberp y) (zerop y))
      x)
    ((and (numberp x) (zerop x))
      y)
    ((and (listp x) (and (member (first x) '(+ -)) (numberp (second x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(,subop (+ ,(second x) ,valvar) ,(third x)))
          (calculate-expr `(+ (,subop ,valvar ,(third x)) ,(second x))))))
;    ((and (numberp y) (numberp x))
;      (+ x y))
    ((and (listp x) (and (member (first x) '(+ -)) (numberp (third x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(+ (,subop ,valvar ,(third x)) ,(second x)))
          (calculate-expr `(,subop (+ ,(second x) ,valvar) ,(third x))))))
;    ((and (listp x) (and (member (first x) '(+ -)) (numberp (second x))))
;      (regroup (first x) '+ (calculate-expr y) (second x) (third x)))
    ((and (listp y) (member (first y) '(+ -)))
        (calculate-expr `(+ ,y ,x)))
;    ((and (listp x) (and (member (first x) '(+ -)) (numberp (third x))))
;      (regroup '+ (first x) (calculate-expr y) (third x) (second x)))
;    ((and (listp y) (member (first y) '(+ -)) (or (numberp (second y)) (numberp (third y))))
;      (calculate-expr `(+ ,y ,x)))
    (t `(+ ,x ,y))))
(defaction - (x y)
  (cond
    ((and (numberp y) (zerop y))
      x)
    ((and (numberp y) (numberp x))
      (- x y))
    ((and (listp x) (and (member (first x) '(+ -)) (numberp (second x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(,subop (- ,(second x) ,valvar) ,(third x)))
          (calculate-expr `(- ,(second x) (,(if (eq subop '+) '- '+) ,valvar ,(third x)))))))
;    ((and (listp x) (and (member (first x) '(+ -)) (numberp (second x))))
;      (regroup-revarg (first x) '- '- (if (eq (first x) '+) '- '+) (calculate-expr y) (second x) (third x)))
    ((and (listp x) (and (member (first x) '(+ -)) (numberp (third x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(- ,(second x) (,(if (eq subop '+) '- '+) ,valvar ,(third x))))
          (calculate-expr `(,subop (- ,(second x) ,valvar) ,(third x))))))
;    ((and (listp x) (and (member (first x) '(+ -)) (numberp (second x))))
;      (regroup-revarg (calculate-expr y) (third x) (second x) (first x) '- '- (if (eq subop '+) '- '+)))
    ((and (listp y) (and (member (first y) '(+ -)) (numberp (second y))))
      (let
        ((valvar (calculate-expr x))
          (subop (if (eq (first y) '+) '- '+)))
        (if
          (numberp valvar)
          (calculate-expr `(,subop (- ,valvar ,(second y)) ,(third y)))
          (calculate-expr `(- (,subop ,valvar ,(third y)) ,(second y))))))
;    ((and (listp y) (and (member (first x) '(+ -)) (numberp (second y))))
;      (regroup (first y) '- (calculate-expr x) (second y) (third y)))
    ((and (listp y) (and (member (first y) '(+ -)) (numberp (third y))))
      (let
        ((valvar (calculate-expr x))
          (subop (if (eq (first y) '+) '- '+)))
        (if
          (numberp valvar)
          (calculate-expr `(- ,(second y) (,subop ,valvar ,(third y))))
          (calculate-expr `(,subop (- ,valvar ,(second y)) ,(third y))))))
;    ((and (listp y) (and (member (first y) '(+ -)) (numberp (third y))))
;      (regroup (first x) '- (calculate-expr y) (third x) (second x)))
    ((equal (calculate-expr x) (calculate-expr y))
      0)
    (t `(- ,x ,y))))
(defaction * (x y)
  (cond
    ((and (numberp x) (equal x 1)) y)
    ((and (numberp y) (equal y 1)) x)
    ((or (and (numberp x) (zerop x)) (and (numberp y) (zerop y)))
      0)
    ((and (numberp x) (numberp y))
      (* x y))
    ((and (listp x) (eq (first x) '+))
      (calculate-expr `(+ (* ,y ,(second x)) (* ,y ,(third x)))))
    ((and (listp x) (eq (first x) '-))
      (calculate-expr `(- (* ,y ,(second x)) (* ,y ,(third x)))))
    ((and (listp y) (eq (first y) '+))
      (calculate-expr `(+ (* ,x ,(second y)) (* ,x ,(third y)))))
    ((and (listp y) (eq (first y) '-))
      (calculate-expr `(- (* ,x ,(second y)) (* ,x ,(third y)))))
    ((and (listp x) (and (member (first x) '(* /)) (numberp (second x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(,subop (* ,valvar ,(second x)) ,(third x)))
          (calculate-expr `(* (,subop ,valvar ,(third x)) ,(second x))))))
    ((and (listp x) (and (member (first x) '(* /)) (numberp (third x))))
      (let
        ((valvar (calculate-expr y))
          (subop (first x)))
        (if
          (numberp valvar)
          (calculate-expr `(* (,subop ,valvar ,(third x)) ,(second x)))
          (calculate-expr `(,subop (* ,valvar ,(second x)) ,(third x))))))
    ((and (listp y) (member (first y) '(* /)) (or (numberp (second y)) (numberp (third y))))
      (calculate-expr `(* ,y ,x)))
    (t `(* ,x ,y))))
(defaction / (x y)
  (cond
    ((and (numberp x) (zerop x))
      0)
    ((and (numberp y) (zerop y))
      'inf)
    ((equal x y)
       1)
    ((and (numberp x) (numberp y))
      (/ x y))
    ((and (listp x) (eq (first x) '+))
      (calculate-expr `(+ (/ ,y ,(second x)) (/ ,y ,(third x)))))
    ((and (listp x) (eq (first x) '-))
      (calculate-expr `(- (/ ,y ,(second x)) (/ ,y ,(third x)))))
    (t `(/ ,x ,y))))
(defaction = (x y)
  (calculate-expr `(- ,x ,y)))
(defaction ^ (x y)
  (cond
    ((and (numberp y) (equal y 0))
      1)
    ((and (numberp y) (equal y 1))
      x)
    (t (calculate-expr (let ((val 1)) (dotimes (i y val) (setf val (calculate-expr `(* ,val ,x)))))))))
